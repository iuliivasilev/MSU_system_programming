          Задание 2: Абстрактный тип данных

Выдача задания                    : 06.03.2008 10:00:00
Крайний срок присылки задания     : 20.03.2008 00:00:00
Сдача задания в МЗ, доработка     : 25.03, ... (по вторникам, 08:45)

Присылка задания (на psut@mail.ru) в срок и очная сдача в МЗ обязательны.

Наибольший балл получают те, кто в срок пришлёт хорошую версию, и в МЗ
не получит серьёзных замечаний. Иначе, оценка за задание определяется
скоростью реакции на замечания. Держите связь.

 **************************

Необходимо на Си++ реализовать и протестировать новый класс, представляющий 
абстрактный тип данных, т.е. такой, пользователи которого могут обращаться
только к публичными операциями, предусмотренными создателем класса, и не имеют
информации о внутреннем его устройстве.

Здесь и далее пользователем (клиентом) класса считается не "пользователь программы" или
"компьютерный пользователь" вообще, а программист, использующий Ваш класс
для решения своих задач, пишущий свою программу на его основе. 
Иногда также под пользователями класса понимаются другие классы,
фрагменты программ, которые пользуются его услугами.

Ниже перечислены варианты понятий, которые нужно представить новым классом.
Можно определить несколько дополнительных классов, на том же уровне или вложенных, 
однако основной проверке подвергается главный класс. В некоторых вариантах
есть подварианты -- одно- или двунаправленный список, чем ограничена длина строки и т.п.,
влияющие на сложность задания. Среди подвариантов нужно сделать свой выбор и отразить его в README. 
Чем сложнее вариант/подварианты, тем больше баллов можно получить за выполненное задание. 

Первые четыре задания сформулированы подробно, остальные -- более кратко,
для интерпретации по аналогии. Полезные замечания разбросаны по 
заданиям, поэтому рекомендуется прочитать их все. :)

Расширение предложенного набора операций, и прочее превышение задания 
(при сохранении правильности базовой части) приветствуется и награждается :)

== Требования к любому варианту ==

Программа формируется в виде следующего набора файлов (например, для стека строк): 

  README
  Makefile
  string_stack.h
  string_stack.cpp
  main.cpp

В файле string_stack.h должно быть объявлено все, что необходимо включить в программу,
использующую класс string_stack, в string_stack.cpp -- описаны реализации нетривиальных методов класса 
(если содержат более одного-двух операторов), краткие методы можно оставить в заголовке.

В main.cpp должна быть реализована программа, тестирующая указанный класс в подробном режиме,
выводя в stderr номера или названия испытаний и их результаты или ошибки. В ходе проверки
задания в первые два файла будут вносится незапланированные изменения, нарушающие работу
класса, и тестирующая программа должна их отлавливать (в том числе и на стадии компиляции,
т.е., она должна содержать явные или неявные обращения ко всем реализованным методам)
 и грамотно диагностировать ошибки (в том числе и на стадии выполнения, например, если метод вернул
не то, что должен), и ни в коем случае не "падать" сама, скажем, по защите памяти (segmentation fault). 

Makefile должен содержать цели clean для уборки за собой, а также test,
которая компилирует main.cpp и прогоняет все тесты (по умолчанию подразумевается цель test).

Для класса, реализующего АТД, необходимо определить: 

 * конструктор по умолчанию
 * конструктор копирования (глубокое копирование, никаких общих ресурсов!)
 * операцию присваивания (все своё предварительно освободить + см. строку выше относительно копирования)
 * деструктор (соответственно, никаких повторных освобождений!)
 * базовый класс исключения, выбрасываемого всеми операциями класса, возможно
   с потомками -- для более детальной классификации ошибок. Вложен в основной класс,
   например string_list::error.

=== Варианты задания (выбрать один и далее определиться внутри) ===

1) список строк (string list)

  строка понимается в стиле Си: char *, на конце \0. 

  Выбрать: 1. Длина строки ограничена константой или объемом оперативной памяти
           2. Однонаправленный или двунаправленный

  Обязательные возможности:

    list( char* )  // конструктор списка из одного элемента

    list + list  // вернуть конкатенацию списков, операнды неизменны
    list += list // присоединить к первому списку, второй неизменен
    char* + list // добавить элемент в начало списка
    list + char* // добавить элемент в конец списка
    list - char* // удалить элемент, если есть
    list[i] // получить копию i-го элемента

    приведение к char* ()  // выписать все элементы через \n

  дополнительные возможности:

    // реализовать независимость всех операций от пробелов в начале или в конце строк, т.е. 
    //   можно добавить "abc ", затем успешно удалить " abc  ".
    list * list   // для списков одной длины, построить список пар через \n, по одной строке из каждого списка
    list[i] = char* // вставить элемент на i-е место, со сдвигом остальных вперед

2) стек строк (string stack)

  строка понимается в стиле Си: char *, на конце \0.

  Стек в обычном понимании (первый вошел -- последний вышел), в котором
  хранятся строки с владением, т.е. при уничтожении вся выделенная под них
  память освобождается. Для сравнения: хранение без владения означает, что
  хранятся и удаляются лишь указатели, а память управляется кем-то еще, тогда
  наш контейнер используется только для организации указателей.

  Выбрать: 1. Длина строки ограничена константой или объемом оперативной памяти.
           2. Емкость стека ограничена константой или параметром конструктора или
              объемом оперативной памяти.

  Обязательные операции:

    stack::push( char* ) // положить копию строки
    char* stack::pop() // вернуть верхний элемент с удалением из стека 
    char* stack::peek() // вернуть копию верхнего элемента без удаления
    int stack::length() // текущий размер
    int stack::maxsize() // максимальный размер (или -1, если "неограничен")

    stack + char*  // синоним push
    stack - char*& // синоним pop, записывающий результат во второй операнд 

3) множество строк (string set)

  строка понимается в стиле Си: char *, на конце \0.

  Выбрать: 1. Длина строки ограничена константой или объемом оперативной памяти.

  Нужно реализовать эффективный тип данных: множество строк. Чаще всего 
  в этом множестве будет осуществляться поиск, поэтому реализовать его нужно
  бинарным деревом поиска. Пользователя нужно избавить от деталей реализации,
  предоставив простой внешний интерфейс.

  Обязательные операции:

    set::add( char* ) // вставка с балансировкой 
    set::member( char* ) // проверка вхождения
    set::delete( char* ) // удалить, если есть
    int set::size() // число элементов

    set + char* // синоним add
    set ^ char* // синоним member
    set - char* // синоним delete

  Дополнительные операции:

    // реализовать незаисимость всех операций от пробелов в начале или в конце строк, т.е. 
    // можно добавить "abc ", затем успешно удалить " abc  ".

    set::optimize()  // перебалансировка дерева. Если это реализовано, 
                     // то вставка всегда осуществляется быстрейшим способом,
                     // без балансировки.
                     // Периодически, когда время позволяет (например, нет
                     // запросов к системе), пользователь класса вызывает optimize
                     // для того, чтобы "утрясти" дерево и ускорить поиск. 


4) вещественная матрица (matrix)

 Вещественным числом считается тип double. 

 Нужно реализовать вещественную матрицу -- понятие линейной алгебры. Нужно
 обеспечить пользователя класса естественным интерфейсом для работы
 с матрицами и составления вычислительных программ.

 Для удобства тестирования и отладки введем строковое представление матрицы,
 похожее за инициализатор двумерного массива. Так, строка

   "{{1, 0, 0}, {0, 1, 0.5}}" 

 обозначает матрицу 2 на 3:

   |   1   0   0 |
   |   0   1 0.5 |
 
 Пробелы в строке не имеют значения. Теперь можно кратко записывать проверки вида: 

   if( matrix::identity( 2 ) != matrix( "{{1,0},{0,1}}" ) ) 
     error( "matrix::identity" );

 Обязательные операции: 

   matrix( int n, int m ) // размера n на m из 0.0
   matrix( double ) // 1 на 1 с этим элементом
   matrix( double*, int m ) // матрица-строка из массива длины m
   matrix( int n, double* ) // матрица-столбец из массива длины n
   matrix( char* ) // из строкового представления (см. выше)

   static matrix matrix::identity( int n ) // возвращает единичную матрицу размера n
   static matrix matrix::diagonal( double* vals, int n ) // возвращает
   // диагональную матрицу размера n с заданными элементами по главной диагонали

   int matrix::rows() // число строк
   int matrix::columns() // число столбцов

   matrix::set( int i, int j, double val ) // присвоить значение элементу [i][j].

   matrix matrix::matrix[ i ] // i-я строка в виде новой матрицы
   matrix matrix::matrix[ j ] // j-й столбец в виде новой матрицы
   // таким образом, становится возможным обращение: m[1][2], 
   // но только на чтение, т.к. конструируются новые объекты-матрицы и 
   // исходные значения становятся недоступны на запись.
   // как этого избежать и допустить присваивание в таком же стиле --
   // см. дополнительные возможности.

   // все арифметические операции выбрасывают исключение, 
   // если матрицы несовместимы по размерам
   matrix + matrix
   matrix += matrix
   matrix - matrix
   matrix -= matrix
   matrix * matrix
   matrix *= matrix
   -matrix // унарный минус, применить ко всем элементам
   matrix == matrix // точность сравнения задана статической константой matrix::EPS
   matrix != matrix

 Дополнительные возможности:

   ~matrix // обратная матрица
   matrix | matrix // конкатенировать (приписать) матрицы вертикально
   // (вторую справа от первой)
   matrix / matrix // конкатенировать (приписать) матрицы горизонально
   // (вторую под первой)

   // реализовать операции индексирования эффективно:
   //   избежать копирования (конструирования) строк и столбцов. 
   //   обеспечить возможность присваивания вида m[1][2] = 5.0;

   double matrix::determinant() // определитель
   matrix matrix::solve() // решить любым способом неоднородную систему из n линейных
   // алгебраических уравнений с n неизвестными, представленную матрицей
   // размера n на (n+1). Вернуть решение в виде матрицы 1 на n.
   // выбросить исключение в случае неразрешимости системы (опять же, с учетом EPS)
   // обязательно запиште какой-нибудь тест в таком виде:
   //   x = (A|b).solve(); if( A*x != b ) { error( "solve" ); }

5) Кусочно-постоянная функция (step function)

   Вещественная функция (double) определенная на всей числовой прямой. 
   Область определения делится на N промежутков (первый и последний --
   полуинтервалы), внутри каждого из которых функция принимает некоторое
   постоянное для этого промежутка значение. На границах всех промежутков 
   непрерывна либо слева, либо справа (выбрать).

   Обязательно придумайте лаконичное строковое представление 
   (наподобие того, что для матриц), сделайте конструктор из него и приведение к нему.  

   Обязательные возможности:
     +, -, *, /, 
     () // значение в точке

   Необязательные возможности:
     численное интегрирование на отрезке

6) Многочлен (polynomial)

  Понятие алгебры. Многочлен степени n от одной вещественной (double) переменной x.

  О текстовом представлении даже не говорю :) "4x^2 + 3x - 2", пробелы
  игнорируем. Преобразование к строке выдает многочлен упорядоченным
  по степеням x, конструктор воспринимает любой их порядок.

  Обязательные возможности:
    () // значение в точке
    +, -, * // возвращают многочлены

  Дополнительные возможности:
    / (деление многочленов с отбрасыванием остатка)
    % (остаток от деления многочленов)
    упрощение (приведение подобных) либо при преобразовании к строке, либо
      поддерживать всегда в приведенном виде
    символьное интегрирование (с построением нового многочлена)
    символьное дифференциирование (с построением нового многочлена)
    определенный интеграл в заданных пределах (возвращает число)
    
7) Граф (graph)

  Понятие дискретной математики. 
  Выбрать: 1) ориентированный (с дугами) или неориентированный (с ребрами)
           2) допускаются ли петли
           3) допускаются ли мультиребра (мультидуги)
           4) допускаются ли пометки (веса) ребер (дуг) (потомки от базового класса "пометка ребра") 

  Текстовое представление.  Например:

    "( (1,2,3,4), ((1,'a', 2),(2,'abc', 3)) )"

  задает граф с вершинами 1, 2, 3 и двумя ребрами: с пометкой "a" из 1 в 2 и с
  пометкой "abc" из 2 в 3, вершина 4 изолирована.

  Придумайте вспомогательные классы "вершина", "ребро (дуга)", которые бы
  незаметно для пользователя конструировались из строк, превращались в строки,
  и т.д.

  Обязательные возможности: 
    добавление вершины, ребра, дуги, удаление их, список дуг, исходящих из вершины; 
    оператор + (объединение графов, добавление вершины, добавление ребра на те же
      вершины или вместе с одной новой вершиной или с двумя новыми вершинами,
      если их еще нет в графе);
    проверка достижимости одной вершины из другой.
    
  Дополнительные возможности.
    поиск путей из вершины в вершину (придумать класс + текстовое
      представление пути);
    поиск циклов;
    поиск сильно связных компонент;
    построение остовного дерева [минимальной стоимости];
    вершинная/реберная раскраска.

8) Дата и время (datetime)

  Реализовать классы для работы с моментами времени и интервалами времени.
  Выбрать: точность представления (до секунды, до миллисекунды).

  Обязательные операции:
    конструкторы и преобразования для текстового представления 
      (момент: "2008-03-06 23:40:01.334" -- сейчас,
       интервал: "2-1-15 00:05:00.000" -- два года, полтора месяца 
       (для интервалов считать их по 30 дней) и 5 минут)
    получить текущий момент времени
    moment - moment = interval,
    moment + interval = moment,
    moment - interval = moment,
    interval + interval = interval,
    interval - interval = interval.

  Необязательные операции:
    интервал * double 
    интервал / double 
    конструктор/преобразование для типа unix timestamp 
      ([milli]seconds since Epoch, google it)
