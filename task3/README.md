# Задание студента 209 группы Васильева Юлия.
### Вариант задания Task3: 
### Моделирование работы интернет-магазина: взаимодействие пользователя,менеджера и разработчика.
-----
## Концепция: ##
Действует интернет-магазин и существует различный вид доступа к нему.
Пользовательские роли: покупатель, разработчик, администратор. 
Первые 2 наследуются от базового класса user, а администратор наследуется от покупателей и разработчиков.
В базовом классе user расположены 2 основные "ячейки хранения" магазина: 
* база товаров для магазина
* корзина для пользователя
Поддерживают работу с этими "ячейками" соответственно классы developer и customer.
"Ячейки хранения" реализованы в качестве однонаправленного связного списка.
Каждый из производных классов имеет свой спектр функций, который работают с этими нашими данными.
---
## Реализация:
Мы создаем переменную производного класса "администратор", 
т.е класса, который в нашем ромбовидном наследовании находится в самом низу.
Всех остальных "работников" мы представляем как ссылки на производный объект "администратор". 
С помощью этих ссылок и организовывается доступ пользователей к их области работы.
То есть мы выбираем статус пользователя(доступ) и от него уже работаем с его функциями.
---
### Методы классов:
#### Уточняющие заметки:
class admin:
В классе используется переменная gift : подарок покупателю за заказ.
При следующем заказе пользователь может попросить у администратора добавить подарок.
Также,подарки можно хранить и добавить сразу несколько одновременно.
В заказе подарок описывается строкой "gift".
##### User
* (no) методы объявлены как чистые виртуальные: Dell(),add(),print(),twin().
* (no)clear() - удаление из "ячейки" товаров, имеющих количество = 0.
##### Customer
* buy(): при выборе имени и кол-ва товара мы находим в магазине желаемый товар и помещаем его в корзину.
* print(): печать текущего состояния нашей корзины.(И для пустой корзины:+)
* Dell(): очистка корзины (внимание!реализация не подразумевает возврата товара и подарков в магазин!)
* twin(): увеличение товаров в корзине х2.(Проверка наличия товаров в магазине: +)
* add(): добавление товара в корзину.(Выделение памяти + добавление в связный список корзины).
##### Deveoper
* print(): печать текущего состояния нашего магазина.(И для пустого магазина:+)
* Dell(): очистка магазина.
* twin(): увеличение товаров в магазине х2.
* add(): добавление товара в магазин.(Выделение памяти + добавление в связный список магазина).
##### Admin #####
* print(): печать текущего состояния нашего заказа(+подарки + наполняемость магазина).
* Dell(): очистка корзины + магазина.
* twin(): увеличение подарков х2.
* add(): добавление подарка в корзину.(Выделение памяти + добавление в связный список корзины).
* use(): обработка заказа (обнуление корзины, начисление подарков) (с учетом пустой корзины:+).
#### Взаимодействие с пользователем(как пользоваться программой): ####
При запуске программы мы должны выбрать любой из интересующих нас классов:
* developer
* customer
* admin
После выбора доступа мы попадаем в общее меню для данного класса.
По команде help мы получаем информацию о возможных командах для этого класса.
Соответственно выбирая команды мы производим какие-то действия над этим классом.
Для выхода из данного класса необходимо ввести команду exit.
При выходе из класса мы снова попадаем в главное меню, из которого выйти можно по той же команде exit.
##### << От автора >>
* Ввод от пользователя дополнительно обрабатывается.
* Система исключений слабо используется, но отлавливает ошибки рода bad_alloc.
* Другие исключения программа ловит, но не распознает.
* При возникновении исключения программа сразу завершается.
* Забавная "ошибка" при отладке: 
 1. пользователь совершает покупку и получает подарок.
 2. пользователь добавляет подарок в корзину
 3. пользователь совершает покупку подарка и получает подарок. Дальше по реккурсии.
### Техническая часть ###
#### Запуск и компиляция: ####
Для реализации класса использовано 4 файла:
1. user.h содержит прототип класса user.
2. customer.h содержит прототип класса customer.
3. developer.h содержит прототип класса developer.
4. admin.h содержит прототип класса admin.
5. customer.cpp содержит функции класса customer.
6. developer.cpp содержит функции класса developer.
7. admin.cpp содержит функции класса admin.
8. test.cpp - тестовый файл, через который пользователь может взаимодействовать с классами.
9. Makefile - осуществляет компиляцию, запуск и очистку.

##### Компиляция м запуск:
* make compile
##### Запуск:
* make run
##### Очистка:
* make clean



#### Обновление 19.03.18 ####
* Обновлено модулирование программы
* Обновлен makefile
* Форматирование стало чуть красивее, но легко ломается.
##### Ответ на дополнительный вопрос:#####
** 1) ** сonst может быть только метод print().  
** 2) ** privat и protected наследование невозможно только из-за построенной архитектуры.  
Т.к admin наследуется от developer, customer, и при работе пользователя мы сначала порождаем admin,  
то при выполнении команд:  
- developer * D = & A;  
- customer * C = & A;  
Будет возникать ошибка, т.к из производного класса мы будем "выделять" protected или privat область,  
а интерфейс пользователя подразумевает прямое взаимодействие с методами классов developer,customer.  
** 3) ** По поводу переноса методов в privat, protected области:  
Единственная функция, которую можно перенести в privat область - функция add в классе customer,  
но из-за использования её в производном класса admin,  
её перенос поменяет интерфейс пользователя и породит достаточное количество переделок.  

** Дополнение по архитектуре **  
*Имя класса admin содержит в себе немного иной смысл: менеджер заказа. *  
*Таким образом, мы изначально в магазине "отдаем" покупателя конкретному менеджеру,  
который уже контролирует его покупки, скидки и статусы заказов.  
Да, для больших магазинов это не удобная и перегруженная структура, однако,  
если использовать её для компаний, занимающихся , например, оптовой продажей товара конкретным фирмам,  
то такая  структура не позволяет ошибиться менеджеру, например, начислить скидку чужой компании.*
-----
